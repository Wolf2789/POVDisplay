#include <Wire.h>

enum LedState { OFF = 0, ON = 1 };
class Display {
  private:
    static byte expander[];
    static byte LEDs[];
  public:
    static void Update();
    static void SetLEDs(byte expander, byte LEDs);
    static void TurnLEDs(byte expander, byte LEDs, LedState state);
};

byte Display::expander[2] = { 0x21, 0x38 };
byte Display::LEDs[] = { 0, 0 };

void Display::SetLEDs(byte expander, byte LEDs) {
  Display::LEDs[expander] = LEDs;
}

void Display::TurnLEDs(byte expander, byte LEDs, LedState state) {
  if (state == ON)
    Display::LEDs[expander] |= LEDs;
  else
    Display::LEDs[expander] &= ~LEDs;
}

void Display::Update() {
  for (byte i = 0; i < 2; i++) {
    Wire.beginTransmission(Display::expander[i]);
    Wire.write(~Display::LEDs[i]); // we're expecting 255 to be all on, but to expander it means all off, so we need to invert our value
    Wire.endTransmission();
  }
}

int IR = 0;
byte IR_countdown = 0;
#define IR_THRESHOLD 900
#define IR_PIN_1 A2
bool doReset = true;
byte currentStep = 0;

void setup() {
  Wire.begin();
}

{ANIMATION SETUP}

void loop() {
  IR = analogRead(IR_PIN_1);
  if (IR_countdown > 0)
    IR_countdown--;
  else {
    if (IR > IR_THRESHOLD)
      doReset = true;
    else if (doReset) {
      doReset = false;
      currentStep = 0;
      IR_countdown = 10;
    }
  }

{ANIMATION CODE}

  Display::Update();
  if ((currentStep += 1) >= MAX_STEPS) {
    Display::SetLEDs(0, 0);
    Display::SetLEDs(1, 0);
    Display::Update();
  }
}